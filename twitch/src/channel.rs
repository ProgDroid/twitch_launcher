pub mod status;

use crate::{
    account::Account,
    secret::{Expose, Secret},
};
use serde::{Deserialize, Serialize};
use status::Status;
use std::{
    fs::read_to_string,
    io::Result,
    process::{Command, Output},
};
use tokio::{spawn, sync::mpsc::UnboundedSender};
use twitch_api::{
    helix::streams::GetStreamsRequest,
    twitch_oauth2::{AccessToken, UserToken},
    HelixClient,
};

#[derive(Serialize, Deserialize, Clone)]
pub struct Channel {
    pub friendly_name: String,
    pub handle: String,
    #[serde(default = "Status::default")]
    pub status: Status,
}

impl Channel {
    #[must_use]
    pub fn new(friendly_name: String, handle: String) -> Self {
        Self {
            friendly_name,
            handle,
            status: Status::default(),
        }
    }

    pub async fn update_status(handle: String, user_access_token: Secret) -> Status {
        let access_token = AccessToken::new(user_access_token.expose_value().to_owned());

        let client: HelixClient<reqwest::Client> = HelixClient::new();

        let user_token =
            match UserToken::from_existing(&reqwest::Client::default(), access_token, None, None)
                .await
            {
                Ok(token) => token,
                Err(e) => {
                    eprintln!("Could not validate token while updating channel status: {e}");
                    return Status::Unknown;
                }
            };

        let req = GetStreamsRequest::user_logins(vec![(&handle).into()]);

        let response = match client.req_get(req, &user_token).await {
            Ok(response) => response,
            Err(e) => {
                eprintln!("Could not get channel status: {e}");
                return Status::Unknown;
            }
        };

        if response.data.is_empty() {
            Status::Offline
        } else {
            Status::Online
        }
    }

    // TODO add support for currently hosting?

    // TODO popup if channel is offline (are you sure?)
    pub fn launch(&self) -> Result<Output> {
        Command::new("powershell")
            .arg("Start-Process")
            .arg("streamlink")
            .arg(format!("twitch.tv/{}", self.handle))
            .arg("-WindowStyle")
            .arg("Hidden")
            .output()
    }

    pub fn launch_chat(&self) -> Result<Output> {
        Command::new("powershell")
            .arg("Start-Process")
            .arg("\"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Chatterino\"")
            .arg(format!("\"-c {}\"", self.handle))
            .output()
    }

    pub fn load_from_file(file: &str) -> Result<Vec<Self>> {
        let data: String = read_to_string(file)?;

        Ok(serde_json::from_str(data.as_str())?)
    }

    pub fn check(channels: &[Self], account: &Account, sender: &UnboundedSender<(String, Status)>) {
        // TODO add cache of statuses?
        for channel in channels {
            let tx = (*sender).clone();

            let channel_handle: String = channel.handle.clone();
            let secret: Secret = account.access_token();

            spawn(async move {
                tx.send((
                    String::from(&channel_handle),
                    Self::update_status(channel_handle, secret).await,
                ))
            });
        }
    }
}

// TODO consider using other format for storing these? e.g. TOML/YAML (easier to type manually but this should be generated by the program)

// TODO need to add account configuration
// TODO github actions to check code?
