use crate::{
    secret::{Expose, Secret},
    twitch_account::TwitchAccount,
};
use serde::{Deserialize, Serialize};
use std::{
    fs::read_to_string,
    io::Result,
    process::{Command, Output},
};
use tokio;
use tokio::sync::mpsc;
use twitch_api2::{
    helix::streams::get_streams,
    twitch_oauth2::{AccessToken, UserToken},
    HelixClient,
};

type LoadResult = Result<(Vec<Channel>, mpsc::Receiver<(String, Status)>)>;

const CHANNELS_FILE: &str = "channels.json";

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[repr(usize)]
pub enum Status {
    Awaiting = 0,
    Online = 1,
    Offline = 2,
    Unknown = 3,
}

impl Default for Status {
    fn default() -> Self {
        Self::Awaiting
    }
}

impl Status {
    #[must_use]
    pub const fn message(&self) -> &'static str {
        match *self {
            Self::Awaiting => "...  ",
            Self::Online => "online",
            Self::Offline => "offline",
            Self::Unknown => "unknown",
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Channel {
    pub friendly_name: String,
    pub handle: String,
    #[serde(default = "Status::default")]
    pub status: Status,
}

impl Channel {
    pub async fn update_status(handle: String, user_access_token: Secret) -> Status {
        let access_token = AccessToken::new(user_access_token.expose_value().to_owned());

        let client: HelixClient<reqwest::Client> = HelixClient::new();

        let user_token =
            match UserToken::from_existing(&reqwest::Client::default(), access_token, None, None)
                .await
            {
                Ok(token) => token,
                Err(e) => {
                    eprintln!(
                        "Could not validate token while updating channel status: {}",
                        e
                    );
                    return Status::Unknown;
                }
            };

        let req = get_streams::GetStreamsRequest::builder()
            .user_login(vec![handle.into()])
            .build();

        let response = match client.req_get(req, &user_token).await {
            Ok(response) => response,
            Err(e) => {
                eprintln!("Could not get channel status: {}", e);
                return Status::Unknown;
            }
        };

        if response.data.is_empty() {
            Status::Offline
        } else {
            Status::Online
        }
    }

    // TODO add support for currently hosting?

    // TODO popup if channel is offline (are you sure?)
    pub fn launch(&self) -> Result<Output> {
        Command::new("powershell")
            .arg("Start-Process")
            .arg("streamlink")
            .arg(format!("twitch.tv/{}", self.handle))
            .arg("-WindowStyle")
            .arg("Hidden")
            .output()
    }

    pub fn launch_chat(&self) -> Result<Output> {
        Command::new("powershell")
            .arg("Start-Process")
            .arg("\"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Chatterino\"")
            .arg(format!("\"-c {}\"", self.handle))
            .output()
    }
}

// TODO consider using other format for storing these? e.g. TOML/YAML (easier to type manually but this should be generated by the program)

pub fn load_channels_from_file(twitch_account: &TwitchAccount) -> LoadResult {
    let data: String = read_to_string(CHANNELS_FILE)?;

    let channels: Vec<Channel> = serde_json::from_str(data.as_str())?;

    load_channels(twitch_account, &channels)
}

#[allow(clippy::unnecessary_wraps)]
pub fn load_channels(twitch_account: &TwitchAccount, channels: &[Channel]) -> LoadResult {
    let (sender, receiver) = mpsc::channel(channels.len());

    // TODO add cache of statuses?
    for channel in channels {
        let tx = sender.clone();

        let channel_handle: String = String::from(channel.handle.as_str());
        let secret: Secret =
            Secret::new(twitch_account.user_access_token.expose_value().to_owned());

        tokio::spawn(async move {
            tx.send((
                String::from(&channel_handle),
                Channel::update_status(channel_handle, secret).await,
            ))
            .await
        });
    }

    Ok(((*channels).to_vec(), receiver))
}

// TODO need to add account configuration
// TODO github actions to check code?
